# Java基础

## 一、集合框架

**Q:说说你知道的集合框架。**  
A: 在Collection接口下的List、Set和Queue。  
1、List接口：  
1.1、ArrayList：  
有序排列，可重复，底层是一个Object类型的数组，初始长度是10，长度不够扩容的时候会变成原来的1.5倍+1，线程不安全。  
在扩容的时候就会去进行复制数据，复制、移动的代价都比较高，适合用来做遍历，不适合做删除、插入。  
  
1.2、LinkedList：有序可重复，底层是双向链表，查询慢，增删块，线程不安全。  
用链表来做存储，很适合数的插入和删除，遍历和随机访问的速度都比较慢。它有专门对表头和表尾操作的方法，可以做双向队列、队列和栈来用。  
  
1.3、Vector:是线程安全的版本的ArrayList,在方法上都加上了synchronized。  

2、Set接口:  
2.1、HashSet:无序不可重复，底层其实是一个HashMap。  
存取数据按照元素的Hash值来计算。如果hash值一样，会接着比较equals方法，只有这两个都相同，才会视为同一个元素。  
  
2.2、TreeSet:使用二叉树实现的。  
每次新增一个元素，都会进行排序，将对象插入到二叉树的指定位置。Integer和String可以直接排序插入，其他类型的需要实现Comparable接口。  
  
2.3、LinkedHashSet：底层是一个LinkedHashMap。  

3、Queue也是Collection接口下的：下面的一些子类，有两端出入的List，用数组或者链表实现。  
  

4、Map接口下面：  
4.1、HashMap：使用的最多，键不可以重复，值可以重复，是一个Hash表，线程不安全，键值都可以是null。  
4.2、HashTable：是线程安全的，键值都不可以是null。  
4.3、TreeMap:是一个二叉树。键不可以重复，值可以重复。  
    


**Q：聊一聊HashMap。**  
A：HashMap，它根据key的hashcode存储数据，能快速定位到value的值。只允许一条记录的key是null,多条记录的value是null。  
在Jdk1.7之前是数组+链表的结构。1.8之后又引入了红黑树。  
Node是他的一个内部类，实现了Map.Entry接口。其实就是一个键值对。  
HashMap是用哈希表来存储的，为了解决哈希冲突，它才用了链地址法，也就是把Kay哈希之后，得到数组下标，把数据放在对应下标元素的链表上。  
插入数据的时候会根据hash算法来定位键值对的存储位置，有时候有两个key会定位到相同的位置，就表示发生了哈希碰撞。  
减少碰撞的办法要么让hash计算的结果分散均匀，或者是让数组变大。  
HashMap就用比较好的hash和扩容机制来解决了hash碰撞的问题。  
初始长度是16，负载因子是0.75，也就是当node的个数到了16*0.75 = 12个的时候，就会进行resize扩容。  
扩容后的大小是原来的两倍。数组的长度也必须是2的n次方。  
当然这也避免不了链表过长，所以在jdk1.8的时候当链表长度大于8的时候，链表就会转为红黑树，来增加查找的效率。  
  
hash算法：  
Hash算法的作用是确定哈希桶数组索引的位置。key的hashcode & (length-1) 来计算下标。    
put方法的流程大致是：  
若哈希桶数组为空就扩容, 不为空，就计算索引，找到存储的位置。  
如果这个位置不存在元素就直接插入，如果存在元素就判断value是否一致，一致就覆盖，不一致就判断是不是红黑树结构。  
如果是红黑树就直接插入，不是就遍历链表准备插入，如果链表的长度大于8，将链表转换为红黑树在插入，不大于8就插入到链表中。  
最后再去判断 ++size 和 数组长度 这两个数据有没有达到扩容的标准，如果达到了就扩容，没有的话插入方法这里才完毕。  

扩容原理：  
扩容时根据元素的数量和数组的总长度来决定的。  
重新计算元素的下标位置，还是用那个算法：key的hashcode & (length-1)。  
jdk1.7是头插方式，先插入的最终会被放到链表的尾部。  
jdk1.8是尾插的方式，在重新计算索引位置之后，可能会被放到新数组的不同位置。  
jdk1.8采用了尾插法的好处是避免了循环链表，在遍历这个链表的时候不会死循环。      
采用头插法，多线程运行扩容程序的时候，put顺序是key1-key2,线程A扩容时候遍历的顺序就是key2-key1，由于头插，key1会在链表的尾部。   
若这个时候线程2再来把key1放到同一个哈希桶中，在扩容好的哈希桶数组上也是用头插法。
因为顺序不能确定就会有...-key1-kay2-key1/...-key2-key1-key2这样的循环链表存在。(_链表的其他节点持有着链表头节点的引用_)   
   
如果使用尾插法，元素的顺序能够固定。哈希桶中的put顺序是key1-key2。key2就会在链表的尾部。   
线程1是扩容的顺序key1-key2的顺序，线程2扩容的时候也就是key1-key2的顺序，在扩容好的哈希桶上也尾插法，会出现 key1-key2-key1.../key2-key1-key2...这样的顺序，
总之是把元素挂到链表的尾部，(_链表上的其他节点不会有链表头节点的引用_)。不会出现循环链表。   
尾插法能够保证扩容前后的链表引用关系。  
用16作为初始容量是为了保证元素的分布均匀。  
因为hash算法去找数组位置的时候，是通过key的hashcode和数组长度-1做与运算，16刚好是2的幂，二进制都是1。  
所以只要kay的hashcode是均匀的，这个算法的结果也就是均匀的，  
这个元素分在数组的位置也是均匀的，为了实现均匀分布，所以容量是2的幂。  
(这里这种解释有点牵强，2,4,8,32也可以啊，为什么默认会是16呢？可能还是因为2,4,8容易引起扩容,32又可能会占用太多空间。16比较折中。)  
再说说负载因子为什么是0.75。因为负载因子这个值是一种空间和时间上的折中值，太小会频繁扩容，浪费空间，太大不及时扩容查询效率会变低。0.75也是一个比较折中的值。  
为什么链表转红黑树的阙值是8。在源码中的注释里面说了，实际使用的时候，随机hashcode哈希桶里面节点个数的分布大概服从泊松分布，为8的概率已经很低了，这个链表转为红黑树的阙值才是8。另外长度是0的概率大概有0.6，也就是其实大多数情况下，hash计算后哈希桶上是没有节点存在的。  
为什么红黑树转为链表的阙值是6。这是为了防止链表和红黑树之间频繁的转换。假如是7的话，再有一个元素被put进入这个哈希桶，就会再次转变为红黑树，频繁的转换比较耗费性能。  
  
如果问哈希表，就简单答一下，别给自己挖坑，避免被追着问。  
哈希表是一种key-value的存储结构，~~对比二叉树\红黑树等树形结构在查询时效率高，删除或者添加时候效率低的特点，数组等结构则是查询效率低，才有人想设计一种在查询和插入删除操作时候效率比较折中的结构~~  
Hash表的设计思想是使用一种算法对key进行运算，拿到运算的结果就能知道改元素的插入或者查询的位置。一种预先知道value位置的思路。  
这就是hash算法，最好的理想情况就是所有key都被算到了不同的位置。  
当然再好的hash算法都会出现hash冲突，~~解决冲突的办法有很多，开发地址、链地址、公共溢出区方法、再散列。~~  
~~主要的是开放地址和链地址用的比较多，开放地址就是把冲突的元素放到与这个元素相邻的空节点上，在查找的时候使用探测方法。线性探测和随机探测，再哈希......~~  
Java的HashMap采用的是链地址的办法，也就是把hash冲突的元素组成一个链表。  
对此Java7和Java8的处理方法又有点不一样。(抛出问题，头插和尾插。)  
_这样回答HashMap，基本就是满分答卷了吧。_  
    


Q:ConcurrentHashMap能说一说吗？  
A
   
   
   





  


## 二、

## 三、

## 四、

## 五、