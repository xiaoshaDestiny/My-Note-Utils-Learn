# MySQL数据库

##事务题
**Q:说一说MySQL的事务。**  
A:事务指的是对数据库中数据的一系列操作要么都成功，要么都失败。  
MySQL中MyISM存储引擎是不支持事务的，InnoDB是支持事务的。  
想要做到这点，一个数据库事务要满足ACID四个特性。
原子性保证不可分割。一致性要求事务发生前后数据都要完整。隔离性保证事务不能被其他事务干扰。持久性保证对数据的改变是永久性的。
  
如果在没有事务隔离的时候，对数据的读取会出现脏读、幻读和不可重复读。  
脏读：A读取到了B修改但是没有提交的数据。  
幻读：A多次读取的过程中被B修改掉了，A多次读取的结果的数量不一样。针对的是插入或者删除。  
不可重复读：A多次读取的过程中被B修改掉了，A多次读取的结果值不一样。针对的是修改。 
   
而一般数据库的隔离级别有四种：  
读未提交：是最低的级别，不能避免脏读、幻读和不可重复读。  
读已提交：是Oracle默认的隔离级别，可以避免脏读。  
可重复读：是MySQL默认的隔离级别，可以避免脏读和不可重复读。  
序列化：可以避免脏读幻读和不可重复读。  
  
另外数据库一般都有7种传播行为，什么是传播行为，也就是一个事务遇到另一个事务，改如何控制：  
常用的是下面这两种：  
propagation_required 需要传播 如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务     
propagation_supports 支持传播 如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行    
   
  
**Q：说一说在开发过程中事务失效的场景。**  
A：在项目中，一般用@Transactional注解去标识事务方法。事务失效的场景有：  
1、使用事务方法没有被Spring管理。  
2、方法不是public的。  
3、自身调用问题，没有使用事务的方法调用使用事务的方法，或者事务方法调用了一个新开事务的方法，这些情况事务都不会起作用。  
4、数据源没有配置Spring的事务管理器。  
5、注解上使用了不支持事务的传播行为。  
6、异常被catch也会使得事务失效。  
7、异常类型错误，默认回滚的是RunTimeException，想要让抛出异常事务回滚，则需要在事务注解上标注Throwable异常类及其子类。  
  

# 索引题   

**Q：说说MySQL数据库的索引。**  
A：数据库的索引是帮助高效获取数据的数据结构。数据库除了数据本身之外，还会维护着一个索引的数据结构。MySQL的索引是用B+树去做的。比如说主键索引就是一种会随着表一起建立的主键索引。  
一般在选择在where中的外键关联字段，经常统计、分组和排序的字段应该建立索引。  
对于表记录比较少，经常会增删改的表，或者是where字句中用不到的字段，这些情况建立索引反而会因为维护索引而降低性能。  
  
**Q:怎么对SQL做性能分析？**
A: 可以使用 explain + sql语句去看 这条SQL执行的情况。  
主要关注的结果列有：   
key列 如果是null,表示没有用到索引。  
rows列 表示这条语句必须检查的行数，如果基本等于表的长度，也不太好。  
type列 如果是all的话表示进行了全表的扫描，也不太行。起码要达到range，就是用到了索引。  
还有最重要的是看extra这一列 如果是出现了Using filesort 文件内排序、Using temporary 临时表(对查询结果进行了排序)说明索引走的情况不是很好。要进行优化了。  
   
**Q:说一些索引失效的场景。**  
A:没有遵守最左前缀原则，使用了is null、不等于、大于小于、索引列上进行了计算、like的通配符写在了最前面、字符串不加单引号，这些情况都会使得索引失效。    
  
  
**Q:生产上是怎么分析的。**  
A:首先是开启数据库的慢查询日志，比如说超过2秒钟的就是慢SQL。   
配置文件里面的那个参数 show_query_log开启日志。设置慢查询的阈值 long_query_time = 2;  
拿到了这些SQL之后可以用explain 在数据中分析。  
还可以用日志分析命令show profile查询SQL在服务器里面的执行细节。  

**Q:对索引的一些优化从哪些方面去考虑？**  
A：1、索引的创建   
2、使用。索引的走不上，从哪些方面考虑  

**Q:如果索引走的不太好，查询很慢这种情况怎么办？**  
A：首先考虑用 force index 强制走一个索引，应急预案。  
然后常用的就是就使用一个覆盖索引加一个最左前缀，把索引重新调整一下，这样去解决。  
  
  
**Q：为什么MySQL用B+树做数据库索引？**    
A：索引是存储在磁盘上的，一般都很大，不可能全部加载到内存，所以做查询的时候只能加载每一页磁盘。  
查询速度比较快的是树结构，而每一个磁盘页对应着索引树的节点，所以磁盘IO次数就由树的高度来决定。  
为了尽量减少IO的次数就需要一种“矮胖”的树，二叉树、二叉搜索树、红黑树，这些树的高度都太高了，不适合，所以选择用红黑树。
  
**Q:那为什么是B+树而不是B树？**  
A:B+树是在B树的基础上为所有的叶子节点加一个指针，所有的数据存储是让叶子节点去做，非叶子节点只保存索引，不保存实际数据。这就跟文件系统非常相似。  
还有就是使用B树在进行范围查询的时候，需要进行一个中序遍历，而用B+树就直接可以遍历到叶子节点，很方便做这种范围的查询。  
  

**Q:热点数据大批量更新是怎么解决的？**    
A： 




# 基础题
**Q:自增主键插入第3条记录，删除第2条记录，把MySQL重启，插入一条记录，这条记录的ID是多少？**  
A:myism把自增主键记录到数据文件中，会是4，innodb把自增主键的最大值记录到内存中，是3。


**Q:在 MySQL 中 ENUM 的用法是什么？**  
A：ENUM 是一个字符串对象，用于指定一组预定义的值，并可在创建表时使用。  
Create table size(name ENUM('Smail,'Medium','Large');

**Q:CHAR 和 VARCHAR 的区别？**  
A：CHAR 列长度固定为创建表时声明的长度，长度值范围是 1 到 255。  
当CHAR 值被存储时，它们被用空格填充到特定长度，检索CHAR值时需删除尾随空格。    


MyIasm是不支持事务的，也不支持数据表的行锁，所以在插入和更新的时候是锁住了整个数据表。  
Innodb是支持事务，并且可以有行锁。    
存储过程是一组特定功能的SQL语句。  
分区分表，将表按照功能模块进行划分，部署到不同的库上，这种叫垂直切分。  
水平切分指的是一个表的数据量过大的时候，将表按照某种规则进行划分，存储到相同结构的表，但是部署在不同的库上。比如说，对id对2取余数，划分到两个库相同结构的表上。  


## 数据库优化
数据库优化的目的，首先是要保证数据库里面数据的一致性和可用性。 
  
### 主从
所以可以首先对数据库进行一个主从的设置，这样数据就有了容灾的备份，也可以做读写的分离，可用性有了很大的保障。
之后来做查询的优化，先要解决一种跨页查询的情况，就是一个数据表的字段太长了，在查询的时候可能要翻过一个磁盘页，
其实这种情况只有极少数的存在，在一些业务系统中可能有这样的数据表存在，但是完全可以用主子细表的关系去将它拆开。
所以比较常见的是做分库分表去优化数据库，当然业界也有有很多成熟的方案去选择。也有很多这样的中间件。
  
### 分库
这种叫垂直切分。
分库的话，其实就是按照业务去划分，每一个小模块都有一个数据库。
  
### 分表
这种叫水平切分。
分表落到具体的实施上，也有很多策略可以选择。  
比如可以把0-10万放在这个表上，10到20万放到另一个表里面。  
也可以建立哈希算法，比如现在是用雪花算法获得的一个数据记录主键，
现在有2个表，id对2取模之后是0的在一个表，是1的在另外一个表，这种办法用的比较多，这样两个表的查询压力就会比较均匀一些。
至于这两个表是不是在一个库里面，我自己觉得按业务去分库，按数据的id取模去分表是比较靠谱的解决办法。
如果分表之后，放在两个数据库上，这样做查询的时候会比较麻烦，我能想到的只能是先把这些在两个库上的数据取出来，然后用Java8的Stream流去进行分组排序这些操作。
当然也有一些比较高端的解决办法，但是涉及到多表连接，排序，分组的时候，就比较难处理了。
但是只是分表，没有让他们分在不同的库上，就可以用Union UnionAll这样的SQL语句去完成，比较方便。
  
### 索引
如果把数据库索引运用得当，在查询的时候会显著的提升SQL的查询速度。  
首先是索引的创建，一定要选择那些筛选效率高的字段，如果筛选效率（标识度很明显）不高，这个B+树在最下层的叶子节点上也会进行一个长时间的链表遍历。  
其次是使用，最左前缀原则，索引列上不计算，%写在右边，尽量不使用not null,>,<,!= 这些词语,根据使用的情况也可以对索引的创建给出一些建议。

