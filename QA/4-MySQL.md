# MySQL数据库

##事务题
**Q:说一说MySQL的事务。**  
A:事务指的是对数据库中数据的一系列操作要么都成功，要么都失败。  
MySQL中MyISM存储引擎是不支持事务的，InnoDB是支持事务的。  
想要做到这点，一个数据库事务要满足ACID四个特性。
原子性保证不可分割。一致性要求事务发生前后数据都要完整。隔离性保证事务不能被其他事务干扰。持久性保证对数据的改变是永久性的。
  
如果在没有事务隔离的时候，对数据的读取会出现脏读、幻读和不可重复读。  
脏读：A读取到了B修改但是没有提交的数据。  
幻读：A多次读取的过程中被B修改掉了，A多次读取的结果的数量不一样。针对的是插入或者删除。  
不可重复读：A多次读取的过程中被B修改掉了，A多次读取的结果值不一样。针对的是修改。 
   
而一般数据库的隔离级别有四种：  
读未提交：是最低的级别，不能避免脏读、幻读和不可重复读。  
读已提交：是Oracle默认的隔离级别，可以避免脏读。  
可重复读：是MySQL默认的隔离级别，可以避免脏读和不可重复读。  
序列化：可以避免脏读幻读和不可重复读。  
  
另外数据库一般都有7种传播行为，什么是传播行为，也就是一个事务遇到另一个事务，改如何控制：  
常用的是下面这两种：  
propagation_required 需要传播 如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务     
propagation_supports 支持传播 如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行    
   
  
**Q：说一说在开发过程中事务失效的场景。**  
A：在项目中，一般用@Transactional注解去标识事务方法。事务失效的场景有：  
1、使用事务方法没有被Spring管理。  
2、方法不是public的。  
3、自身调用问题，没有使用事务的方法调用使用事务的方法，或者事务方法调用了一个新开事务的方法，这些情况事务都不会起作用。  
4、数据源没有配置Spring的事务管理器。  
5、注解上使用了不支持事务的传播行为。  
6、异常被catch也会使得事务失效。  
7、异常类型错误，默认回滚的是RunTimeException，想要让抛出异常事务回滚，则需要在事务注解上标注Throwable异常类及其子类。  
  

# 索引题   

**Q：说说MySQL数据库的索引。**  
A：数据库的索引是帮助高效获取数据的数据结构。数据库除了数据本身之外，还会维护着一个索引的数据结构。MySQL的索引是用B+树去做的。比如说主键索引就是一种会随着表一起建立的主键索引。  
一般在选择在where中的外键关联字段，经常统计、分组和排序的字段应该建立索引。  
对于表记录比较少，经常会增删改的表，或者是where字句中用不到的字段，这些情况建立索引反而会因为维护索引而降低性能。  
  
**Q:怎么对SQL做性能分析？**
A: 可以使用 explain + sql语句去看 这条SQL执行的情况。  
主要关注的结果列有：   
key列 如果是null,表示没有用到索引。  
rows列 表示这条语句必须检查的行数，如果基本等于表的长度，也不太好。  
type列 如果是all的话表示进行了全表的扫描，也不太行。起码要达到range，就是用到了索引。  
还有最重要的是看extra这一列 如果是出现了Using filesort 文件内排序、Using temporary 临时表(对查询结果进行了排序)说明索引走的情况不是很好。要进行优化了。  
   
**Q:说一些索引失效的场景。**  
A:没有遵守最左前缀原则，使用了is null、不等于、大于小于、索引列上进行了计算、like的通配符写在了最前面、字符串不加单引号，这些情况都会使得索引失效。    
  
  
**Q:生产上是怎么分析的。**  
A:首先是开启数据库的慢查询日志，比如说超过2秒钟的就是慢SQL。   
配置文件里面的那个参数 show_query_log开启日志。设置慢查询的阈值 long_query_time = 2;  
拿到了这些SQL之后可以用explain 在数据中分析。  
还可以用日志分析命令show profile查询SQL在服务器里面的执行细节。  

**Q:对索引的一些优化从哪些方面去考虑？**  
A：1、索引的创建   
2、使用。索引的走不上，从哪些方面考虑  

**Q:如果索引走的不太好，查询很慢这种情况怎么办？**  
A：首先考虑用 force index 强制走一个索引，应急预案。  
然后常用的就是就使用一个覆盖索引加一个最左前缀，把索引重新调整一下，这样去解决。  
  
  
**Q：为什么MySQL用B+树做数据库索引？**    
A：索引是存储在磁盘上的，一般都很大，不可能全部加载到内存，所以做查询的时候只能加载每一页磁盘。  
查询速度比较快的是树结构，而每一个磁盘页对应着索引树的节点，所以磁盘IO次数就由树的高度来决定。  
为了尽量减少IO的次数就需要一种“矮胖”的树，二叉树、二叉搜索树、红黑树，这些树的高度都太高了，不适合，所以选择用红黑树。
  
**Q:那为什么是B+树而不是B树？**  
A:B+树是在B树的基础上为所有的叶子节点加一个指针，所有的数据存储是让叶子节点去做，非叶子节点只保存索引，不保存实际数据。这就跟文件系统非常相似。  
还有就是使用B树在进行范围查询的时候，需要进行一个中序遍历，而用B+树就直接可以遍历到叶子节点，很方便做这种范围的查询。  
  

**Q:热点数据大批量更新是怎么解决的？**    
A： 




# 基础题
**Q:自增主键插入第3条记录，删除第2条记录，把MySQL重启，插入一条记录，这条记录的ID是多少？**  
A:myism把自增主键记录到数据文件中，会是4，innodb把自增主键的最大值记录到内存中，是3。


**Q:在 MySQL 中 ENUM 的用法是什么？**  
A：ENUM 是一个字符串对象，用于指定一组预定义的值，并可在创建表时使用。  
Create table size(name ENUM('Smail,'Medium','Large');

**Q:CHAR 和 VARCHAR 的区别？**  
A：CHAR 列长度固定为创建表时声明的长度，长度值范围是 1 到 255。  
当CHAR 值被存储时，它们被用空格填充到特定长度，检索CHAR值时需删除尾随空格。    


MyIasm是不支持事务的，也不支持数据表的行锁，所以在插入和更新的时候是锁住了整个数据表。  
Innodb是支持事务，并且可以有行锁。    
存储过程是一组特定功能的SQL语句。  
分区分表，将表按照功能模块进行划分，部署到不同的库上，这种叫垂直切分。  
水平切分指的是一个表的数据量过大的时候，将表按照某种规则进行划分，存储到相同结构的表，但是部署在不同的库上。比如说，对id对2取余数，划分到两个库相同结构的表上。  


## 数据库优化
数据库优化的目的，首先是要保证数据库里面数据的一致性和可用性，然后去优化效率。  
  
### 主从
所以可以首先对数据库进行一个主从的设置，这样数据就有了容灾的备份，也可以做读写的分离，可用性有了很大的保障。  
之后来做查询的优化，先要解决一种跨页查询的情况，就是一个数据表的字段太长了，在查询的时候可能要翻过一个磁盘页，
其实这种情况只有极少数的存在，在一些业务系统中可能有这样的数据表存在，但是完全可以用主子细表的关系去将它拆开。  
所以比较常见的是做分库分表去优化数据库，当然业界也有有很多成熟的方案去选择。也有很多这样的中间件。  
  
### 分库
这种叫垂直切分。  
分库的话，其实就是按照业务去划分，每一个小模块都有一个数据库。
  
### 分表
这种叫水平切分。  
分表落到具体的实施上，也有很多策略可以选择。    
比如可以把0-10万放在这个表上，10到20万放到另一个表里面。    
也可以建立哈希算法，比如现在是用雪花算法获得的一个数据记录主键。    
现在有2个表，id对2取模之后是0的在一个表，是1的在另外一个表，这种办法用的比较多，这样两个表的查询压力就会比较均匀一些。  
至于这两个表是不是在一个库里面，我自己觉得按业务去分库，按数据的id取模去分表是比较靠谱的解决办法。  
如果分表之后，放在两个数据库上，这样做查询的时候会比较麻烦，我能想到的只能是先把这些在两个库上的数据取出来，然后用Java8的Stream流去进行分组排序这些操作。  
当然也有一些比较高端的解决办法，但是涉及到多表连接，排序，分组的时候，就比较难处理了。  
但是只是分表，没有让他们分在不同的库上，就可以用Union UnionAll这样的SQL语句去完成，比较方便。  
  
### 索引
如果把数据库索引运用得当，在查询的时候会显著的提升SQL的查询速度。    
首先是索引的创建，一定要选择那些筛选效率高的字段，如果筛选效率（标识度很明显）不高，这个B+树在最下层的叶子节点上也会进行一个长时间的链表遍历。     
其次是使用，最左前缀原则，索引列上不计算，%写在右边，尽量不使用not null,>,<,!= 这些词语,根据使用的情况也可以对索引的创建给出一些建议。  


给数据表的字段添加索引的目的就是为了高效的查询数据库中的数据。
1、索引能很有效的减少扫描磁盘的次数，索引像一个字典的目录一样把数据进行数据的区间提前找出来。
2、索引能帮助快速排序和避免临时表的生成。当一个带排序的查询语句交给MySQL执行的时候，MySQL会把数据都加载到内存中，然后按照排序字段生成一张临时表。
如果这个临时表的默认大小超过了16M，那内存的临时表就会转变为磁盘的临时表，这时候性能会很差。
由于索引本身就是有序的，那么从磁盘读取到的数据也就是有序的，也就不用去创建临时表。
3、索引能将随机IO变成瞬息IO。数据是存在了每一个磁盘页的扇区上，如果没有索引，数据就会是随机的分散在各个扇区的不同磁道上。那么由于磁盘IO的瓶颈就会影响这次查询的效率。
有索引的时候就不一样，因为数据在磁盘页上是连续的，在读写的时候就变成了顺序IO。

### 索引的分类  
#### B+树索引
B+树的树高比较低，从根节点到叶子节点就可以理解成一次IO操作，查数据的时候就不需要扫描全部的磁盘页，顺着跟节点层层去找子节点就好了。
每一个节点的大小就是一个磁盘块的大小，叶子节点通过指针相互连接，就减少了遍历时候的随机IO，并且叶子节点是排好序的。
#### 哈希索引
是一种哈希表的实现，通过key值进行哈希算法之后就能很快的找到value的值，在value里面一般就存储了指向数据行的指针。
这种索引结构查询起来比较快，也很紧凑。但是缺点也很明显，就是区间查找，排序，分组这些情况就不支持了。

Innodb本身是不支持哈希索引的，只是在B+树索引的某些字段访问过于频繁的时候才会去建立一种自适应的哈希索引来协助B+树索引达到一个更好的查询效率。

#### 回表
MySQL中 主键是一个唯一的聚集索引。当一个SQL在查询的时候用到了普通的索引，但是查询的列表并不能在索引字段中全部包含，
这时候普通索引无法直接获得所有查询列表的行记录数据信息，只是定位出来了需要查询的主键，需要再次走一遍聚集索引才能找到这行数据。
使用覆盖索引就能避免回表。

#### 高性能索引策略
索引失效的场景：
1、索引列进行了计算，也就是含有表达式或者函数 select id from table where id + 1 = 5
2、索引发生了类型转化，比如字符串到数字的转化。
3、在多表查询的时候，由于表的字符集不是一样的，也会导致索引失效。

#### 前缀索引和索引选择性
前缀索引，当要对查询长字符串的SQL语句进行优化的时候，可以使用前缀索引，也就是只将字符串的前几位最为索引，就避免了索引太大的问题。
那么选择多少个字符呢？其实只要将不重复的索引值和整个表的记录总数做一个比值计算就好了，比值越高就代表选择区分度越大。也就越好。
唯一索引，比如说主键所构成的聚集索引，比值是1，选择性最好。
那在前缀索引里面，可以使用
select 
count (distinct left(str,3)) / count(*) as sel3,
count (distinct left(str,4)) / count(*) as sel4,
count (distinct left(str,5)) / count(*) as sel5,
count (distinct left(str,6)) / count(*) as sel6,
from table_a
这样的一个简单计算，就可以找出选择多少个字符最合适。
（对数据表中table_a的str字段建立一个前缀索引，分别查询前3个，4个，5个，6个字符在整个表记录中的不重复比例，越高的越好）

### 索引设计准则：三星索引


