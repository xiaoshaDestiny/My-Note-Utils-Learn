《Java并发编程的艺术》
# 第一章 并发编程的挑战
## 上下文切换
CPU给每个任务分配时间片，CPU不停的切换线程执行。任务从保存到加载就是一次上下文的切换。   
创建多的线程不一定会使得执行效果高于单线程处理，因为CPU上下文的切换也会带来恨大的性能开销。   
### 如何减少上下文的切换
(1)无锁并发编程，将数据按照ID进行Hash运算取模分段，不同的线程处理不同段的数据。   
(2)CAS 自旋操作，Atomic包下的包装数据类型使用了CAS算法来进行数据更新，不需要加锁。   
(3)使用协程，使用最少线程，避免创建不需要的线程，在单线程里面实现多任务调度，并在单线程里维持多个任务之间的切换。 
### 避免死锁
(1)避免一个线程同时获取多个锁。  
(2)避免一个线程在锁内部同时占用说个资源，尽量保证一个锁占用一个资源。
(3)尝试使用定时锁，使用try-lock来替代使用内部锁机制。  
(4)对于数据库锁，加锁和解锁必须是在一个数据库连接里面，否则会出现解锁失败的情况。  
### 资源限制带来的挑战
程序执行的速度受到软硬件资源的限制。并发编程的原则是将串行代码执行的部分变成并发执行，但是因为资源的限制，程序可能不仅不会加快，反而因为CPU上下文的切换导致资源调度的时间更长。  
2Mb/s的带宽，下载速度是1Mb/s，启动多个线程之后不会变成10Mb/s  
如果是硬件资源带来的限制，可以考虑集群方案。不同的数据交给不同的机器去处理。数据ID%机器数量取模，得到的就是处理这个数据的机器编号。  
对于软件资源来限制，可以采用资源的复用策略，使用连接池将数据库连接和Socket连接复用，或者在调用服务获取接口的时候，只建立一个连接。  

# 第二章 Java并发机制的底层实现原理
## volatile的应用

