《Java并发编程的艺术》
# 第一章 并发编程的挑战
## 上下文切换
CPU给每个任务分配时间片，CPU不停的切换线程执行。任务从保存到加载就是一次上下文的切换。   
创建多的线程不一定会使得执行效果高于单线程处理，因为CPU上下文的切换也会带来恨大的性能开销。   
### 如何减少上下文的切换
(1)无锁并发编程，将数据按照ID进行Hash运算取模分段，不同的线程处理不同段的数据。   
(2)CAS 自旋操作，Atomic包下的包装数据类型使用了CAS算法来进行数据更新，不需要加锁。   
(3)使用协程，使用最少线程，避免创建不需要的线程，在单线程里面实现多任务调度，并在单线程里维持多个任务之间的切换。 
### 避免死锁
(1)避免一个线程同时获取多个锁。  
(2)避免一个线程在锁内部同时占用说个资源，尽量保证一个锁占用一个资源。
(3)尝试使用定时锁，使用try-lock来替代使用内部锁机制。  
(4)对于数据库锁，加锁和解锁必须是在一个数据库连接里面，否则会出现解锁失败的情况。  
### 资源限制带来的挑战
程序执行的速度受到软硬件资源的限制。并发编程的原则是将串行代码执行的部分变成并发执行，但是因为资源的限制，程序可能不仅不会加快，反而因为CPU上下文的切换导致资源调度的时间更长。  
2Mb/s的带宽，下载速度是1Mb/s，启动多个线程之后不会变成10Mb/s  
如果是硬件资源带来的限制，可以考虑集群方案。不同的数据交给不同的机器去处理。数据ID%机器数量取模，得到的就是处理这个数据的机器编号。  
对于软件资源来限制，可以采用资源的复用策略，使用连接池将数据库连接和Socket连接复用，或者在调用服务获取接口的时候，只建立一个连接。  

# 第二章 Java并发机制的底层实现原理
## volatile的应用

如果一个变量被声明为 volatile ,Java的线程内存模型能够确保所有线程看到这个变量的值是一致的。

### CPU术语
内存屏障：一组处理器指令，用来实现对内存操作的顺序限制  
缓冲行：缓存中可以分配的最小存储单位。处理器填写缓存线的时候会加载整个缓存线需要使用多个主内存读周期  
原子操作：不可中断的一个或者一系列操作  
缓存行填充：当处理器识别到从内存中读取操作数是可缓存的，处理器读取整个缓存行到适当的缓存(L1,L2,L3)  
缓存命中：如果进行高速缓存行填充操作的内存位置仍然是下次处理器访问的地址时，处理器从缓存中读取操作数，而不是从内存中读取  
写命中：当处理器将操作数写回到一个内存缓存的区域时，它会首先检查这个缓存的内存地址是否在缓存行中，如果存在一个有效的缓存行，则处理器将这个操作数写回到缓存，而不是写回到内存，这个操作被称为写命中    
写缺失：一个有效的缓存行被写入到不同的内存区域  

### 如何保证可见性？
在堆volatile变量进行写操作的时候，会编译生成一个Lock前缀的CPU指令，在多核的CPU处理器下回引发两件事情：  
1、将当前处理器缓存行的数据写回到系统内存中。  
2、这个写回内存的操作会使在其他CPU里缓存了改内存地址的数据无效。  
为了确保各个处理器的缓存是一致的，就会实现缓存一致性协议，每一个处理器都会去嗅探在总线上传播的数据来检查自己缓存的值是不是过期了。
当发现自己缓存行内对应的内存地址被修改，就会将当前缓存行设置成无效状态，当处理器对这个数据进行操作的时候，那就直接从系统内存中把这个数据读到处理器的缓存里面。

**Lock前缀的指令会引起处理器缓存回写到内存：**    
Lock这个指令不会锁总线，而是锁缓存，锁总线的开销比较大。 
   
**一个处理器的缓存回写到内存，会导致其他处理器上的缓存无效：**    
Intel的处理器会使用MESI控制协议去维护内部缓存和其他处理器缓存的一致性。处理器使用嗅探技术保证它的内部缓存、系统内存和其他处理器缓存的书记在总线上保持一致。

### volatile的优化
Doug lea在JDK7的并发包里面新增了一个队列集合类 Linked-TransferQueue,在使用volatile变量的时候使用了一种追加字节的方式来优化性能。他把共享变量的长度追加多个4个字节的引用扩充到64个字节。    
因为intel的多款CPU的l1,l2,l3缓存的高速缓存行都是64个字节宽的，并且是不支持部分行填充的，采用这种追加字节填满到缓存行宽度的办法，处理器就会把这个数据都读到同一个高速缓存行里面。  


## synchronized的实现原理和应用
普通同步方法：锁是当先实例对象  
静态同步方法：锁是当前类的Class对象  
同步方法块：  锁是括号里面的对象  

JVM基于进入和退出Monitor对象实现同步，代码块是使用monitorenter和monitorexit来实现。对于方法，在编译之后会被标识为ACC_SYNCHRONIZED也是隐式的调用了这一组指令。   
在编译之后，同步代码开始的地方插入monitorenter指令，在异常和方法结束的时候插入monitorexit指令，JVM保证了相互匹配，并且在异常的时候也能正常释放monitor对象，避免死锁。    
### Java对象头
synchronized用的锁存在Java对象头里面，如果对象是数组，JVM用3个字宽存储对象头，非数组用2个字宽。
Java的对象头存储了对象的HashCode,分代年龄和锁标记位。
### 锁升级

JDK1.6引入了偏向锁和轻量级锁。
- 1、偏向锁  
HotSpot虚拟机的作者研究发现，大多数情况下锁不仅不存在竞争，并且是由一个线程多次获得。所以当一个线程访问同步代码块的时候，就会在对象头和栈帧中的锁记录里面存放偏向线程的ID。
之后在进入和退出同步代码块的时候只需要简单的测试一下 



