《Java并发编程的艺术》
# 第一章 并发编程的挑战
## 上下文切换
CPU给每个任务分配时间片，CPU不停的切换线程执行。任务从保存到加载就是一次上下文的切换。   
创建多的线程不一定会使得执行效果高于单线程处理，因为CPU上下文的切换也会带来恨大的性能开销。   
### 如何减少上下文的切换
(1)无锁并发编程，将数据按照ID进行Hash运算取模分段，不同的线程处理不同段的数据。   
(2)CAS 自旋操作，Atomic包下的包装数据类型使用了CAS算法来进行数据更新，不需要加锁。   
(3)使用协程，使用最少线程，避免创建不需要的线程，在单线程里面实现多任务调度，并在单线程里维持多个任务之间的切换。 
### 避免死锁
(1)避免一个线程同时获取多个锁。  
(2)避免一个线程在锁内部同时占用说个资源，尽量保证一个锁占用一个资源。
(3)尝试使用定时锁，使用try-lock来替代使用内部锁机制。  
(4)对于数据库锁，加锁和解锁必须是在一个数据库连接里面，否则会出现解锁失败的情况。  
### 资源限制带来的挑战
程序执行的速度受到软硬件资源的限制。并发编程的原则是将串行代码执行的部分变成并发执行，但是因为资源的限制，程序可能不仅不会加快，反而因为CPU上下文的切换导致资源调度的时间更长。  
2Mb/s的带宽，下载速度是1Mb/s，启动多个线程之后不会变成10Mb/s  
如果是硬件资源带来的限制，可以考虑集群方案。不同的数据交给不同的机器去处理。数据ID%机器数量取模，得到的就是处理这个数据的机器编号。  
对于软件资源来限制，可以采用资源的复用策略，使用连接池将数据库连接和Socket连接复用，或者在调用服务获取接口的时候，只建立一个连接。  

# 第二章 Java并发机制的底层实现原理
## volatile的应用
CPU术语
内存屏障：一组处理器指令，用来实现对内存操作的顺序限制  
缓冲行：缓存中可以分配的最小存储单位。处理器填写缓存线的时候会加载整个缓存线需要使用多个主内存读周期  
原子操作：不可中断的一个或者一系列操作  
缓存行填充：当处理器识别到从内存中读取操作数是可缓存的，处理器读取整个缓存行到适当的缓存(L1,L2,L3)  
缓存命中：如果进行高速缓存行填充操作的内存位置仍然是下次处理器访问的地址时，处理器从缓存中读取操作数，而不是从内存中读取  
写命中：当处理器将操作数写回到一个内存缓存的区域时，它会首先检查这个缓存的内存地址是否在缓存行中，如果存在一个有效的缓存行，则处理器将这个操作数写回到缓存，而不是写回到内存，这个操作被称为写命中    
写缺失：一个有效的缓存行被写入到不同的内存区域  
