# JVM

### Q:JRE,JDK,JVM是什么？
A:JRE 是Java应用运行的最小环境，jvm和一些类库组成。  
JDK 是Java开发的最小环境，由JRE和Java工具共同组成。  
JVM 即Java Virtual Machine是一台执行Java字节码指令的虚拟计算机，并不是Java语言才能生生字节码指令。  
jvm有良好的跨语言性，强大的垃圾回收机制和可靠的即时编译器，让JVM真正的能够坐到一次编译，处处运行。  
所有的Java程序都将运行在Java虚拟机的内部，但是JVM是运行在操作系统之上的摩根底层的硬件没有直接的做交互。  

### Q:说一说JVM的整体结构。
A:JVM整体可用分为：类加载子系统，运行时数据区，执行引擎和本地方法接口。    
其中类加载子系统负责将class文件加载进入JVM中运行，整个加载过程分为加载、链接和初始化。    
执行引擎可以分成三个部分，解释器、即时编译器和垃圾回收器三个部分。  
本地方法接口则是调用C/C++语言编写的底层native方法。  

### Q:说一说类加载子系统。
Java虚拟机把描述类的数据从Class文件加载到内存，对数据进行校验、转换解析和初始化，这个过程就叫虚拟机的类加载。  
Java中的类加载器有:启动类加载器 BootstrapClassLoader, 扩展类加载器 ExtensionClassLoader和应用程序类加载器 ApplicationClassLoader
双亲委派模型   
如果一个类加载器收到了加载类的请求，先不尝试去加载，而是把加载请求委派给父类加载器去完成，
父类加载器无法完成这个加载请求的时候才会反馈给子类加载器（负责的范围内没有搜索到所需的类），子类加载器才会去加载。
这样就保证了不会重复加载，也保证了核心类的安全，也就是常说的沙箱安全机制。  
  
加载完成之后是链接，链接分为验证、准备和解析三个阶段。
验证：
主要是确保Class文件不会危害到jvm自身的安全，比如说是不是以CAFEBABY开头，主次版本号有没有在虚拟机接收的范围之内。
也会进行一些简单的语义分析，继承的时候有没有把抽象类的方法都实现，是不是出现了final类被继承的错误等等。
一般在生产上，可以通过参数 -XVerify:none去关闭大部分的验证，缩短虚拟机加载类的时间。  

准备：
为类中定义的变量（被static修饰的变量）分配内存，并且初始化零值。
int类型是0， float类型是0.0 ，boolean 是false，char类型就是 -u0000，引用类型都是null。
但是不包括final修饰的变量，final类型的变量在编译的时候就赋值了。
而实例变量会随着对象实例化的时候随着对象一起分配在堆中。

解析：
解析要做的就是把常量池里面的符号引用转换为直接引用。符号引用就是一些字面量，直接引用要么是对象的地址，要么就是句柄。（句柄池里面的引用，间接定位对象地址）

初始化：
到这里的时候，虚拟机才把程序的流程控制交给代码，因为这里回去执行<clinit>方法，也就是类构造器，这个方法是编译的产物，但不是构造方法，构造方法是<init>
既然是交给程序执行，那么一定有线程安全问题，虚拟机会给这个方法加锁，保证初始化过程的线程安全。

加载(三加载器双亲委派) ->  链接{ 验证(字节码安全) -> 准备(给0值) -> 解析(符号引用变为直接引用) } -> 初始化( <clinit>类构造器 编译产物 )

### Q：说一说JVM的内存分区。(运行时数据区，JVM内存模型)
JVM把运行时数据划分成：堆、方法区、虚拟机栈、本地方法栈和程序计数器。
1、程序计数器就是一个存放当前线程下一条需要执行指令的地址，每个线程私有一份。若线程执行的是Java方法，值是指令地址。若线程执行的是本地方法，值是Undefine.不会OOM。    
2、虚拟机栈是方法执行的内存模型，描述的是方法的调用，一个方法调用就是一个栈帧的压栈，方法返回就是栈帧的出栈。每个线程私有一份。
这个区域在方法递归的次数超过栈深度的时候会有StackOverFlow，若运行虚拟机栈扩容，则在申请不到足够内存的时候出现OOM。  
3、本地方法栈，与虚拟机栈类似，只是执行的是C/C++语言编写的Native方法。也是每个线程各自私有一份。  
4、方法区，所有线程共享，存放的是被虚拟机加载的类型信息，常量，即时编译器编译之后的代码缓存等，Class文件加载之后的常量池也会放到这个地方，各种字面量和符号引用。当无法申请到足够多内存的时候，会报OOM。
5、堆，虚拟机中空间占比最大的一块区域。存放对象实例，并不一定是物理连续的内存空间，但逻辑上是连续的。基本上所有的垃圾收集器都是基于分代收集理论而设计的，所以堆空间会被划分成新生代、老年代、永久代等
新生代被细化分成伊甸园区，幸存者0区和幸存者1区。堆空间在创建对象的时候无法分配足够内存的时候会报OOM.


### HotSpot虚拟机在新建对象的时候到底发生了什么？   
检查要创建的对象的类型是否在常量池中存在,没在就去执行类加载过程，然后为这个对象分配内存，所需要的内存空间大小在类加载之后是能够确定的。
如果堆内存时规整的，没有碎片，就用指针碰撞，把界限指针往空闲方挪动即可。假设内存时不规整的，虚拟机就必须维护一个记录堆空间使用情况列表，从列表中找出一块足够大的空间划分给该对象。  
一般内存是否规整由选择的垃圾收集器去决定。
然后创建的动作要保证线程的安全，采用CAS配合自旋的失败重试办法。 
当然也有一种办法是把内存划分一部分缓冲区给线程的方式，然后用同步锁去保证线程安全。这种办法叫TLAB。
然后是将内存空间初始化零值，保证对象的实例字段在不给初值的情况下能直接使用。
然后是初始化对象头的信息，对象的GC分代年龄，属于哪一个类的实例，怎么寻找对象的元数据信息等。  
之后才是去执行构造方法。

### Java对象的内存布局
一个Java对象在堆内存中的结构由三部分组成：对象头,实例数据，对齐填充。  
对象头：有两部分组成，第一部分是对象自身的运行时数据：hashCode,GC分代年龄，锁状态标志，线程持有的锁，偏向线程的ID,偏向时间戳等。
另一部分是类型指针，对象指向它元数据的指针，通过这个指针来判断是能够类的实例。  
实例数据：对象真正存储的有效信息，longs/doubles,ints,oops等......相同宽度字段总是分配到一起存放。  
对齐填充：补充这个对象到8字节的整数倍。





