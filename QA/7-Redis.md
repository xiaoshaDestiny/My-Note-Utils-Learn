# Redis
Redis能问的东西实在是太多了，会被螺旋问，掌握的不够深最好就尽量避免回答。

## 基础
**Q:说一说Redis**  
A:Redis是一款高性能的Key-value NoSQL数据库，读写速度极快，也叫内存数据库。提供了String Hash List Set ZSet五种数据类型的支持。
因为Redis是单线程的，所以对数据的操作是能保证原子性的。同时也支持事务，使用MULTI(标记事务开始)，EXEC(执行事务语句块)和WATCH(监视key)指令能完成对数据的事务性操作。
另外Redis还支持将数据进行持久化操作，提供了RDB快照和AOF记录两种形式的持久化策略，在Redis重启的时候能快速回复数据。持久化也可以说是一种容灾手段。
Redis支持集群，主从复制等形式进行容灾备份，极大的提升了数据的高可用性。
因为Redis及高的性能，在项目使用的还是蛮多的。~~（别答，别挖坑。热点数据缓存，计数器相关场景，分布式ID生成器，分布式缓存等场景，大部分是作为缓存）~~
在我所参与的项目里面，Redis大部分情况是做为热点数据的缓存来降低数据库压力。
  
**Q:说一说缓存雪崩。**  
A:首先是大批量的缓存失效导致大量的请求直接去查询到数据库。导致缓存失效的原因可能是Redis集群故障，或者大批量更新热点数据，或者是缓存数据同一时间大量失效等。  
数据库承载不住，导致不可用甚至进而导致查询服务宕机，进而导致的整个系统不可用。  
解决方案：
1、从集群本身上来说，配置Redis的高可用性。持久化等策略。  
2、服务调用方面进行限流，当QPS达到一定的阈值的时候设置限流和降级规则，优先保证服务不被冲垮，限流之后让少量的请求去进行热点数据的缓存恢复。
3、为缓存配置不同的失效时间，避免同时大规模缓存失效。  
4、还有就是在系统上线的时候也容易出现，这时候先进行缓存预热，让Redis有一部分热点数据再提供服务。

**Q:说一说缓存击穿。**
A:缓存击穿指的是用户查询数据再数据库中没有，自然Redis缓存中也不会有，这样每次查询数据的时候都进行了两次无用查询。常用的解决办法有两种。  
一种是把这个数据库中空的结果也进行缓存，缓存失效的时间设置的短一点，给个几分钟，这样下一次查询的时候就能命中缓存了。几分钟之后再去查询数据库，有就缓存，为空也缓存。实现起来比较方便。  
另外一种是解决办法是使用布隆过滤器，类似于HashMap,一个key进过多个Hash函数落到不同的下标上，假如这些下标上的值都是1那么就能说明数据是存在的。如果有一个下标为0，那么数据就肯定是不存在的。  
这种方法极小的概率可能误判有，但一定不会错判没有。极其偶然的情况也就是可能出现结果全是1但是没有的情况，但是不会出现结果中存在0但是数据有这种情况。  

**Q:说一说缓存更新。**  
A:根据自己的业务需求去配置不同的缓存更新策略，比如说定期清理，但是要注意设置时间尽量错开。还有就是用户请求过来之后如果缓存失效就把缓存刷新等。都是常用的措施。
 
 
**Q:Redis为什么能这么快。**  
A：1、对数据请求的处理是纯内存操作，数据结构类似于HashMap。  
2、采用了单线程，避免了上下文切换时候不必要的资源消耗，也不用考虑各种锁的问题。  
3、采用了IO的多路复用。

**Q:说一说Redis集群。**  
A:Redis集群是保证高可用中重要的一环。通过slaveof ip加端口的模式来让一个Redis服务器称为另一个服务器的从服务器。这就是主仆模式。
主服务器创建数据快照文件，发送给从服务器，从服务器丢弃所有旧数据，载入主服务器的快照文件。之后主服务器没执行一次写相关的命令就向从服务器发送相同的命令，来达到集群数据的一致性。
在传输的过程中，主服务器会把这段传输时间内发生在主服务器上的命令，写在缓冲区中。从机宕机重连之后也会恢复到主服务器的数据。
而在生产上使用哨兵模式，当主服务器宕机之后，自动从这些从服务器中选举出新的主服务器。

**Q:说一说用Redis实现分布式锁**  
A:
setnx key value  （set if not exists）如果不存在key，则设置key的值。  
setex key seconds value 将value关联到key上，并且设置存活时间，如果已经存在key,将覆盖原来的value值。  
实现Redis锁，先用setnx加锁。下一个线程来setnx 相同key的时候就会返回0，使用这种方式就可以在分布式环境下保证顺序，实现锁。  
但是锁资源不及时释放就会导致安全问题，执行报错的时候容易导致死锁。所以要对这个key设置过期时间，其他服务在获取锁的超时时间大于这个失效时间的时候就退出，重新来获取锁资源。  
并且setnx和设置失效时间需要保证原子性操作。value的值最好是一个全局的唯一ID，可以使用雪花算法来生成。  

然后是解锁，加锁和解锁需要保证是同一个客户端来操作，大体思路是在加锁成功之后让Redis把value的值返回，客户端在解锁的时候进行判断返回的value和提交的value是否一致，一致则把key删除即可。  
这一连串操作需要使用lua脚本操作来保证原子性。  

仔细回想加锁跟释放锁这一步操作，大致好像没有什么问题，但是如果业务处理的时间长于锁的失效时间呢？  
现在我了解到的比较好的处理方案是Redisson，它有一个续约的动作，就是锁快要过期，发现业务还没有处理完，就去延长10秒钟这个key的过期时间。  

**Q:秒杀系统一般存在什么问题？**
A: 高并发请求的时候，缓存的一系列问题，雪崩，击穿，穿透这些，没做服务的降级限流熔断容易把数据库搞垮，还会导致超卖，链接暴露时候还会被恶意请求。等等。
解决这些的大致思路是：服务单一职责，秒杀的后台单独部署，数据库分库分表，不至于搞垮全部网站。  
对于链接暴露这种情况把URL链接进行加盐加密。  
对于Redis进行集群化部署，主从，哨兵模式配置，加上持久化，保证高可用。  
Nginx做反向代理，负载均衡。  
服务配置限流，熔断，降级策略。  
前端页面设置按钮不可点击。  
对于超卖这种问题，可以把库存先放到redis,然后使用lur脚本的CAS去保证原子性。  
对于订单的后续操作可以使用MQ进行削峰。  

**Q:Redis跳跃表知道吗？**
A:在有序链表的基础上加上多个索引层之后的数据结构。  
一般查询效率比较好的是平衡树结构，但是需要在插入或者删除之后去调整整个树，比较麻烦。跳跃表在牺牲了一些空间之后换来了高效的读写操作。  































