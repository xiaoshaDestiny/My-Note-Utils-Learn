# Redis
Redis能问的东西实在是太多了，会被螺旋问，掌握的不够深最好就尽量避免回答。

## 基础
**Q:说一说Redis**  
A:Redis是一款高性能的Key-value NoSQL数据库，读写速度极快，也叫内存数据库。提供了String Hash List Set ZSet五种数据类型的支持。
因为Redis是单线程的，所以对数据的操作是能保证原子性的。同时也支持事务，使用MULTI(标记事务开始)，EXEC(执行事务语句块)和WATCH(监视key)指令能完成对数据的事务性操作。
另外Redis还支持将数据进行持久化操作，提供了RDB快照和AOF记录两种形式的持久化策略，在Redis重启的时候能快速回复数据。持久化也可以说是一种容灾手段。
Redis支持集群，主从复制等形式进行容灾备份，极大的提升了数据的高可用性。
因为Redis及高的性能，在项目使用的还是蛮多的。~~（别答，别挖坑。热点数据缓存，计数器相关场景，分布式ID生成器，分布式缓存等场景，大部分是作为缓存）~~
在我所参与的项目里面，Redis大部分情况是做为热点数据的缓存来降低数据库压力。
  
**Q:说一说缓存雪崩。**  
A:首先是大批量的缓存失效导致大量的请求直接去查询到数据库。导致缓存失效的原因可能是Redis集群故障，或者大批量更新热点数据，或者是缓存数据同一时间大量失效等。  
数据库承载不住，导致不可用甚至进而导致查询服务宕机，进而导致的整个系统不可用。  
解决方案：
1、从集群本身上来说，配置Redis的高可用性。持久化等策略。  
2、服务调用方面进行限流，当QPS达到一定的阈值的时候设置限流和降级规则，优先保证服务不被冲垮，限流之后让少量的请求去进行热点数据的缓存恢复。
3、为缓存配置不同的失效时间，避免同时大规模缓存失效。  
4、还有就是在系统上线的时候也容易出现，这时候先进行缓存预热，让Redis有一部分热点数据再提供服务。

**Q:说一说缓存击穿。**
A:缓存击穿指的是用户查询数据再数据库中没有，自然Redis缓存中也不会有，这样每次查询数据的时候都进行了两次无用查询。常用的解决办法有两种。  
一种是把这个数据库中空的结果也进行缓存，缓存失效的时间设置的短一点，给个几分钟，这样下一次查询的时候就能命中缓存了。几分钟之后再去查询数据库，有就缓存，为空也缓存。实现起来比较方便。  
另外一种是解决办法是使用布隆过滤器，类似于HashMap,一个key进过多个Hash函数落到不同的下标上，假如这些下标上的值都是1那么就能说明数据是存在的。如果有一个下标为0，那么数据就肯定是不存在的。  
这种方法极小的概率可能误判有，但一定不会错判没有。极其偶然的情况也就是可能出现结果全是1但是没有的情况，但是不会出现结果中存在0但是数据有这种情况。  

**Q:说一说缓存更新。**  
A:根据自己的业务需求去配置不同的缓存更新策略，比如说定期清理，但是要注意设置时间尽量错开。还有就是用户请求过来之后如果缓存失效就把缓存刷新等。都是常用的措施。
 
 
**Q:Redis为什么能这么快。**  
A：1、对数据请求的处理是纯内存操作，数据结构类似于HashMap。  
2、采用了单线程，避免了上下文切换时候不必要的资源消耗，也不用考虑各种锁的问题。  
3、采用了IO的多路复用。

**Q:说一说Redis集群。**  
A:Redis集群是保证高可用中重要的一环。通过slaveof ip加端口的模式来让一个Redis服务器称为另一个服务器的从服务器。这就是主仆模式。
主服务器创建数据快照文件，发送给从服务器，从服务器丢弃所有旧数据，载入主服务器的快照文件。之后主服务器没执行一次写相关的命令就向从服务器发送相同的命令，来达到集群数据的一致性。
在传输的过程中，主服务器会把这段传输时间内发生在主服务器上的命令，写在缓冲区中。从机宕机重连之后也会恢复到主服务器的数据。
而在生产上使用哨兵模式，当主服务器宕机之后，自动从这些从服务器中选举出新的主服务器。

**Q:说一说用Redis实现分布式锁**  
A:setnx （set if not exists）不存在key，则设置key的值


